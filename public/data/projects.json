{
	"projects": [
		{
			"id": "blog",
			"title": "Blog",
			"description": "A blog connected to an API, with GET and POST functionality. There's a form with its corresponding validation, success and error messages, an archive of posts with pagination, and a nice loader.",
			"image_1x": "/images/blog_1x.png",
			"image_2x": "/images/blog_2x.png",
			"alt": "The blog home page showing a form on the left side and the latest blog posts on the right side.",
			"link": "/project/blog",
			"tags": ["React", "TypeScript", "Tailwind CSS"],
			"github": "https://github.com/ndemia/sb-blog",
			"demo": "https://blog-sb.netlify.app/",
			"content": [
				{
					"type": "title",
					"text": "Context"
				},
				{
					"type": "paragraph",
					"text": "One more of my interview tests. The first time I did it, I didn't even know React! It was on my list of things to learn, and I hadn't arrived to it yet. Despite of this, they sent it to me and I decided to give it a shot. It took me several days of 'crash-coursing' React at the same time I was building it, which was not the best approach. It was stressful and I made a ton of mistakes. Nonetheless, and despite a lot of shortcomings, I managed to build most of it but it was not enough. So after a while and having learned a bit more about React, I had a need to tackle this project again."
				},
				{
					"type": "title",
					"text": "Design"
				},
				{
					"type": "paragraph",
					"text": "Initial designs were provided, but they weren't consistent or accessible, so I redesigned it while still maintaining the original layout to align with the original requirements."
				},
				{
					"type": "title",
					"text": "Tech Stack"
				},
				{
					"type": "paragraph",
					"text": "React, TypeScript, JavaScript, Tailwind CSS."
				},
				{
					"type": "title",
					"text": "Purpose and goal"
				},
				{
					"type": "paragraph",
					"text": "After several months of studying and learning more about React, I was feeling comfortable enough to give this test another try. I aimed to build it completely this time around. I felt like I owed it to myself because I knew I could do it. And it would be a good experience too."
				},
				{
					"type": "title",
					"text": "Requirements"
				},
				{
					"type": "list",
					"items": [
						"Blogposts should be able to be created in the form on the left side of the Home page. An API endpoint was provided. All inputs should be required. This form should provide a user-friendly experience.",
						"On the right side there should be a preview of the latest 4 posts. There should also be a button to load the next 4 posts. Those posts should be appended to the current posts, not replaced.",
						"On the Blog page, there should be an archive of all the blogposts. These posts should be able to be paginated, so that the user can navigate to next or previous pages.",
						"The user should be able to navigate to the different pages."
					]
				},
				{
					"type": "title",
					"text": "Spotlight"
				},
				{
					"type": "paragraph",
					"text": "Without a doubt, the feature that took the most time (and perhaps coolest too) was the custom useFetch hook that could work with GET and POST requests. This includes the ability to use it from any place on the page targeting different API endpoints, and handling different types of responses."
				},
				{
					"type": "title",
					"text": "Obstacles"
				},
				{
					"type": "paragraph",
					"text": "Creating the custom useFetch felt like a monumental task. From the start, my goal was to build it so that it could handle both types of fetch requests, but since I've never done it like this before, I started small just with GET requests. And from there, I built up. I enjoyed the flexibility of setting the fetch properties in an object that I could then change or update according to the type of request. It was also cool to see how the state could change, in different parts of the page, depending on the state of the fetch request."
				},
				{
					"type": "paragraph",
					"text": "Another due I had, at this point, was incorporating TypeScript to React. I was already used to working with plain TypeScript (as in my other projects), but after adding it to React it felt like a different thing for a while, with a complexity of its own. For the most part, TypeScript inferred everything amazingly well, but there were moments where dedicated extra steps were needed or new ways in which to cast types, to narrow them. Some new errors also came up, especially when working with specific objects' keys, but those were solvable with just a quick online search."
				},
				{
					"type": "paragraph",
					"text": "Building the form was the easy part, and handling the data and error validation was the most complex part. I learned that I could manage both the inputs' values and form errors with objects, which was an approach I had never done. It was pretty cool and straightforward. Originally, I was not aware of certain limitations that the API demanded for each of the input's values. The documentation didn't say anything about them, so it was a matter of trying each one to get an error response. That's how I found out about the 255-character limit for text inputs, the category input can't be empty, and the maximum file size was 3MB. I like the result, and the errors show appropriately."
				},
				{
					"type": "paragraph",
					"text": "Lastly, not having had enough with React and TypeScript, I decided to throw Tailwind into the mix. I was very curious about it, after having tried Styled Components. Since it was my first time with it, the learning curve was steep, and it took a lot of time to get the hang of it. For every property, I was reading the documentation about how to write it. That made progress slower. For this small project, I'm not sure of the benefits of Tailwind, as I found myself several times using arbitrary values. It's certainly interesting, so I'll continue to explore it."
				},
				{
					"type": "title",
					"text": "What I learned"
				},
				{
					"type": "paragraph",
					"text": "A ton of things! Ok, perhaps not THAT much, but it certainly feels like it. After finishing, I checked the original code I sent for this test, and I could see a lot of things I had done wrong. Which makes sense because, back then, I hadn't had any experience with it. In addition, I'm already seeing things I can improve in my website which I also built with React, so that means I made progress, yay! I'm intrigued about the idea of custom hooks, so I'll be sure to try that more in the future, if possible. I'm still trying to understand some of the concepts behind React, but I got more comfortable with it, for sure."
				}
			]
		},
		{
			"id": "marketplace",
			"title": "Medieval marketplace",
			"description": "A small marketplace to buy shields and swords. There are some nice animations, validation checks, and it even comes with optional sound effects for an enhanced experience.",
			"image_1x": "/images/marketplace_1x.png",
			"image_2x": "/images/marketplace_2x.png",
			"alt": "A modal window serving as a market for medieval items like swords and shields.",
			"link": "/project/marketplace",
			"tags": ["HTML", "CSS", "TypeScript"],
			"github": "https://github.com/ndemia/marketplace",
			"demo": "https://ndemia.github.io/marketplace/",
			"content": [
				{
					"type": "title",
					"text": "Context"
				},
				{
					"type": "paragraph",
					"text": "One more installment in my series of interview tests. This time for a SaaS company specialized in workspace software. Until now, this assignment has been the most difficult one. It's great to say that I've been able to correct a lot of previous mistakes that I've made in the first iteration of this project."
				},
				{
					"type": "title",
					"text": "Design"
				},
				{
					"type": "paragraph",
					"text": "A design was provided, but I decided to replace it with one that was more fun."
				},
				{
					"type": "title",
					"text": "Tech Stack"
				},
				{
					"type": "paragraph",
					"text": "HTML, CSS (SASS), TypeScript."
				},
				{
					"type": "title",
					"text": "Pre-built part"
				},
				{
					"type": "list",
					"items": [
						"There is a web application with a pre-authenticated user.",
						"Each user has an amount of gold coins, which is shown somewhere in the top bar.",
						"There is a stock of items to offer, with a price in gold coins and an available amount. E.g.: 3 swords costing 35 each and 2 helmets costing 12 each and so on.",
						"For the simplicity of the setup, pre-built storage is in-memory (i.e. some static collections) and the requests to the “back-end” are simulated (see service.js)."
					]
				},
				{
					"type": "title",
					"text": "Part to be built"
				},
				{
					"type": "list",
					"items": [
						"Make “Buy” button in the top bar show the dialog which will allow user to buy available items (to be displayed in a modal).",
						"Users can see available items and their price, can type in an amount to buy (integer value), or increment/decrement it with buttons + and -.",
						"Total cost is calculated in real-time and reflects changes to the amount. If the total cost exceeds available money, message appears and buy button is disabled.",
						"When user clicks 'Buy', dialog is closed, item stocks are updated and user balance is updated. There is no need to store bought items. User can also close the dialog via cancel or close buttons.",
						"Make sure constraints with regard to number of items available and user balance are not violated.",
						"Make sure feedback is available to users if they cannot accomplish the action (e.g. item is no longer available or a request to the backend fails).",
						"A 'random' failure request is implemented for the “Buy” request (e.g. once every 3 requests) and the failure is handled."
					]
				},
				{
					"type": "title",
					"text": "Implementation requirements"
				},
				{
					"type": "list",
					"items": [
						"Existing features should continue to function.",
						"The domain logic described for the dialog is implemented (real-time updating, constraints/validation checks, updating of the user/stock on purchase, feedback on failure).",
						"A “random” failure request is implemented for the 'Buy' request (e.g. once every 3 requests) and the failure is handled.",
						"You don't need to have any database or backend (changes) though if you feel like giving it a try, you can. We do however expect you to write a service / proxy which returns promises to simulate requests to the backend (preferable including some random failures).",
						"The original test used jQuery but since I'm learning TypeScript, I decided to do use it for this iteration of the project."
					]
				},
				{
					"type": "title",
					"text": "Obstacles"
				},
				{
					"type": "paragraph",
					"text": "The first time I did this project I didn't comprehend that the database worked as an API, and replaced it with a Class. It worked, but it was not the original intention. So this time around, I reverted to the original code and worked with it."
				},
				{
					"type": "paragraph",
					"text": "The API handled requests for each piece of information individually, which makes sense: you request the user, or you request the stock. Each request has a 1 in 3 chance to fail (by design). A lot of the logic for the checks during the purchasing process depends on these calls to validate the available item quantity, for example. As well as the item's price, especially when calculating total prices. With so many checks, calls, and potential failures, the challenge was to keep calls to a minimum, which I managed to achieve! Now it only makes one call to the API, and then it just passes that information around between the functions that need it."
				},
				{
					"type": "paragraph",
					"text": "Another challenge arose from creating the validation checks during the purchasing process. It was hard, and also confusing at times, with many functions checking the same values, and other checking their return values. A lot of things going on."
				},
				{
					"type": "title",
					"text": "Accessibility"
				},
				{
					"type": "paragraph",
					"text": "I got more comfortable using a screen-reader. I learned about the inert attribute (and its polyfill), and how to use it to 'disable' parts of the website so that they would not be keyboard accessible. In this particular case, disabling the 'back' of the website while the modal is open."
				},
				{
					"type": "paragraph",
					"text": "I also got familiar with 'aria-live' and 'role' attributes so that screen readers can announce changes in the UI. For example, when prices update, alerts and error messages appear. Lastly, I got more comfortable with aria-label, aria-hidden, and improving keyboard navigation overall."
				},
				{
					"type": "title",
					"text": "What I learned"
				},
				{
					"type": "paragraph",
					"text": "TypeScript allowed me to better understand JavaScript, in a way. I has also helped me write better, more structered code. It certainly took some time getting used to it, but I can already see the benefits."
				},
				{
					"type": "paragraph",
					"text": "I also got more comfortable with promises and asynchronous JavaScript, as well as with handling errors, and managing the flow of information."
				}
			]
		},
		{
			"id": "movie",
			"title": "Movie Search",
			"description": "A simple movie search website that uses The Open Movie Database.",
			"image_1x": "/images/movie_1x.png",
			"image_2x": "/images/movie_2x.png",
			"alt": "Movie search results.",
			"link": "/project/movie",
			"tags": ["HTML", "CSS", "TypeScript"],
			"github": "https://github.com/ndemia/movie-search",
			"demo": "https://ndemia-movie.netlify.app/",
			"content": [
				{
					"type": "title",
					"text": "Context"
				},
				{
					"type": "paragraph",
					"text": "This assignment was part of the process for a position at a payments processor company. It's great to realize that I managed to make a lot of improvements from what I originally did."
				},
				{
					"type": "title",
					"text": "Tech Stack"
				},
				{
					"type": "paragraph",
					"text": "HTML, CSS (SASS), TypeScript."
				},
				{
					"type": "title",
					"text": "Requirements"
				},
				{
					"type": "list",
					"items": [
						"The assignment was meant to be completed in vanilla JavaScript, without any frameworks or libraries. But to practice I rebuilt it using TypeScript.",
						"It was not allowed to use any external libraries to manage the request either (Axios or similar).",
						"Mobile-first approach.",
						"Each result should have its own card (or among those lines, can't remember exactly as it was long ago and I haven't kept the documentation)."
					]
				},
				{
					"type": "title",
					"text": "Obstacles"
				},
				{
					"type": "paragraph",
					"text": "It was my first time dealing with pagination and it was the most difficult part. I had to rely on a third-party solution to accomplish it, but not before understanding how it works. Although I do need to practice it more often, it's still complicated to achieve while providing a good user experience."
				},
				{
					"type": "paragraph",
					"text": "Dealing with the card layout was also tricky since there's always going to be some undesired whitespace, whether inside the car to match all the heights, or outside to avoid it. I chose the latter one in this case."
				},
				{
					"type": "paragraph",
					"text": "Another challenge was learning how to manage and hide the API key. I didn't get it the first time I did this assignment, but this time I did. And it's pretty cool! Since I also learned about Netlify, a bit more about Node.js, which I use today."
				},
				{
					"type": "title",
					"text": "What I learned"
				},
				{
					"type": "paragraph",
					"text": "I got more comfortable with asynchronous code in general, as well as TypeScript. Learned about Netlify, working with external APIs, hiding API keys in environment variables, and deploying the project. Got more familiar with testing accessibility (keyboard navigation and using screen-readers)."
				}
			]
		},
		{
			"id": "daily",
			"title": "Daily UI",
			"description": "A collection of different UIs designed and built by me.",
			"image_1x": "/images/dailyui_1x.png",
			"image_2x": "/images/dailyui_2x.png",
			"link": "/project/daily",
			"alt": "A calculator made over a grandient background.",
			"tags": ["HTML", "CSS", "JavaScript"],
			"github": "https://github.com/ndemia/daily-ui",
			"demo": "https://ndemia.github.io/daily-ui/",
			"content": [
				{
					"type": "title",
					"text": "Context"
				},
				{
					"type": "paragraph",
					"text": "Here you will find a diverse collection of UI work. Some from the Daily UI challenge, others inspired or based on design work that I did, and others from Frontend Mentor. These are all prototypes."
				}
			]
		}
	]
}
